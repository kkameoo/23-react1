# 한동길

## 13주차 23.05.25

### 여러 개의 컨텍스트 사용하기

+ 여러개의 컨텍스트를 동시에 사용하려면 Context.Provider를 중첩해서 사용함

+ 2개 또는 그 이상의 컨텍스트 값이 자주 함께 사용될 경우 모든 값을 한 번에 제공해 주는 별도의 render prop 컴포넌트를 직접 만드는 것을 고려하는 것이 좋음

### useContext

+ 함수형 컴포넌트에서 컨텍스트를 사용하기 위해서 Hook을 사용

+ useContext()혹은 React.creatContext()함수 호출로 생성된 컨텍스트 객체를 인자로 받아서 현재 컨텍스트의 값을 리턴함

+ 이 방법도 가장 가까운 상위 Provider로 부터 컨텍스트의 값을 받아옴

### 스타일링


## 12주차 23.05.18

### 합성 과 상속

+ 합성은 '여러 개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는 것'

### Containment

+ 특정 컴포넌트가 하위 컴포넌트를 포함하는 형태의 합성방법
+ 컴포넌트에 따라서는 어떤 자식 엘리먼트가 들어올 지 미리 예상할 수 없는 경우가 있음
+ 범용적인 '박스'역활을 하는 sidebar 혹은 Dialog와 같은 컴포넌트를 종종 볼 수 있음
+ 이런 컴포넌트에서는 children prop을 사용하여 자식 엘리먼트를 출력에 그대로 전달하는 것이 용이함
+ 이때 children prop은 컴포넌트의 props에 기본적으로 들어있는 children속성을 사용

### Specialization

+ 범용적인 개념을 구별이 되게 구체화 화는 것을 특수화라고 함
+ 객체지향 언어에서는 상속을 사용하여 특수화를 구현
+ 리액트에서는 합성 사용해서 특수화를 구현

### 상속

+ 합성과 대비되는 개념으로 상속이 있음
+ 자식 클래스는 부모 클래스가 가진 변수나 함수 등의 속성을 모두 갖게 되는 개념
+ 하지만 리액트에서는 상속보다는 합성을 통해 새로운 컴포넌트를 생성
+ 복잡한 컴포넌트를 쪼개 여러 개의 컴포넌트로 만들고, 만든 컴포넌트등을 조합하여 새로운 컴포넌트를 만들어야 함


### 컨텍스트

+ 기존의 일반적인 리액트에서는 데이터가 컴포넌트의 props를 통해 부모에게 자식으로 단방향으로 전달됨

+ 컨텍스트는 리액트 컴포넌트를 사이에서 데이터를 기존의 props를 통해 전달하는 방식 대신 '컴포넌트 트리를 통해 곧바로 컴포넌트에 전달하는 새로운 방식'을 제공

+ 컨텍스트를 통해 컴포넌트라도 쉽게 데이터에 접근 가능

+ 컨텍스트를 사용하면 일일이 props로 전달할 필요 없이 곧바로 데이터를 전달 가능

### 언제 사용해야 하는가?

+ 여러 컴포넌트에서 자주 필요로 하는 데이터는 로그인 여부,로그인 정보, UI 테마,현재 선택된 언어 등이 있음

+ 예제처럼 props를 통해 데이터를 전달하는 기존 방식은 실제 데이터를 필요로 하는 컴포넌트까지의 깊이가 깊어질 수록 복잡해 짐

+ 또 반복적인 코드를 계속해서 작성해 주어야 하기 때문에 비효율적이고 가독성이 떨어짐

+ 컨텍스트를 사용하면 이러한 방식을 깔끔하게 개선할 수 있음

### 사용하기 전 고려사항

+ 컨텍스트는 다른 레벨의 많은 컴포넌트가 특정 데이터를 필요로 하는 경우에 주로 사용

+ 무조건 컨텍스트를 사용하는 것이 좋은 것은 아님

+ 왜냐.. 컴포넌트와 컨텍스트가 연동되면 재사용성이 떨어지기 때문

+ 따라서 다른 레벨의 많은 컴포넌트가 데이터를 필요로 하는 경우가 아니면 props를 통해 데이터를 전달하는 컴포넌트 합성 방법이 더 적합

### React.createContext

+ 컨텍스트를 생성하기 위한 함수

+ 파라메타에는 기본값을 넣어주면 됨

+ 하위 컴포넌트는 가장 가까운 상위 레벨의 Provider로 부터 컨텍스트를 받게 되지만, 만일 Provider를 찾을 수 없다면 기본값을 사용하게 됨

- const MyContext = React.createContext(기본값);

### Context.Provider

+ Context.Provider 컴포넌트로 하위 컴포넌트들을 감싸주면 모든 하위 컴포넌트들이 해당 컨텍스트의 데이터에 접근할 수 있게 됨

- <MyContext.Provider value={/* some value */}>

+ Provider 컴포넌트에는 value라는 prop이 있고, 이것은 Provider 컴포넌트 하위에 있는 컴포넌트에게 전달됨

+ 하위 컴포넌트를 consumer 컴포넌트라고 부름

### Class.contextType

+ provider 하위에 있는 클래스 컴포넌트에서 컨텍스트의 데이터에 접근하기 위해 사용
+ Class 컴포넌트는 더 이상 사용하지 않으므로 참고만 함

### Context.Consumer

+ 함수형 컴포넌트에서 Context.Consumer를 사용하여 컨텍스트를 구독할 수 있음

+ 컴포넌트의 자식으로 함수가 올 수 있는데 이것을 function as a child라고 부름

+ Context.Consumer로 감싸주면 자식으로 들어간 함수가 현재 컨텍스트의 value를 받아서 리액트 노드로 리턴함

+ 함수로 전달되는 value는 Provider의 value prop과 동일함

### Context.displayName

+ 컨텍스트 객체는 dispalyName이라는 문자열 속성을 갖습니다.

+ 크롬의 리액트 개발자 도구에서는 컨텍스트의 Provider나 Consumer를 표시할 떄 displayName 을 함께 표시해 줌

## 11주차 23.05.11

### 컴포넌트

## 10주차 23.05.04

### 리스트와 키

### 1. 리스트와 키란?

+ 리스트 자바스크립트의 변수나 객체를 하나의 변수로 묶어 놓은 배열과 같은 것
+ 키는 각 객체나 아이템을 구별할 수 있는 고유한 값을 의미
+ 리액트에서는 배열과 키를 사용하는 반복되는 다수의 엘리먼트를 쉽게 렌더링할 수 있음
+ map() 함수 사용
+ 키는 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 됨
+ 인덱스 값을 키값으로 사용하는 것이 권장되지 않음(id값을 명시)

### 폼
+ 일반적으로 사용자로부터 입력을 받기위한 양식에서 많이 사용됨

### 제어 컴포넌트
+ 제어 컴포넌트는 사용자가 입력한 값에 접근하고 제어할 수 있도록 해주는 컴포넌트


## 9주차 23.04.27

### 1. 이벤트 처리

+ Dom - onclick= "..." 
+ React - onClick= {}
+ 차이점 - 함수를 문자열로 그대로 가져오는것과 함수자체를 가져옴
+ '' - c -> C 소문자에서 대문자로 바뀜

### 2.클래스 컴포넌트
+ bind를 사용해서 글로벌 스코프에서 호출되는것을 방지
+ 또는 화살표 함수 사용
+ 클래스 컴포넌트같은 경우는 요즘에는 잘 사용하지 않으니 참고만

### 3.함수형 컴포넌트
+ 방법 1. 함수 안에 함수로 정의
function ...() {    
}
+ 방법 2. 화살표 함수 사용
const ... = () => {
}

### 4.Arguments 전달하기
+ foo_bar -> 스네이크 방식
+ foo-bar -> 케이스 방식

+ 함수를 정의할 때는 파라미터 or 매개변수 라고 부름
+ 함수를 사용할 때는 아규먼트 or 인수 라고 부름

------------------------------------------------
### 1. 조건부 렌더링

+  if 문에서 조건문으로 전달받은 값에 따라 다른 결과를 리턴한다

### 2. 엘리먼트 변수
+ 렌더링해야 될 컴포넌트를 변수처럼 사용하는 방식

### 3. 인라인 조건
+ 필요한 곳에 조건문을 직접 넣어 사용하는 방식
+ &&논리 연산자를 사용함
+ &&는 and연산자로 모든 조건이 참일때만 참이 됨
+ 첫 번째 조건이 거짓이면 두 번째 조건은 판단 할 필요가없음
+ 판단만 하지 않고 결과 값은 그대로 리턴

### 4. 인라인 if-else
+ 삼항 연산자를 사용 - 조건문 ? 참일 경우 : 거짓일 경우
+ 문자열이나 엘리먼트를 넣어서 사용 가능

### 5.컴포넌트 렌더링 막기

+ 컴포넌트를 렌더링 하고 싶지 않을때에는 null을 리턴한다.




## 8주차 23.04.20

+ 중간고사 시험

## 7주차 23.04.13

### 1. 훅이란..
+ 클래스형 컴포넌트에서는 생성자에서 state를 정의하고, setState() 함수를 통해 state를 업데이트함
+ 예전에 사용하던 함수형 컴포넌트는 별도로 state를 정의하거나, 컴포넌트의 생명주기에 맞춰서 어떤 코드가 실행되도록 할 수 없었다
+ 함수형 컴포넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 훅 이다

### 2. useState
+ useState는 함수형 컴포넌트에서 state를 사용하기 위한 Hook이다

### 3. useEffect
+ usestate와 함께 가장 많이 사용하는 hook
+ 이 함수는 사이드 이펙트를 수행하기 위한 것
+ 부작용을 의미하고, 버그가 발생하는것을 의미
+ 리액트에서는 영향 , 효과에 더 가까움
+ 첫 번째 파라미터는 이펙트 함수가 들어가고, 두 번째 파라미터로는 의존성 배열이 들어감

--- useEffect(이펙트 함수, 의존성 배열); ----

### 4. useRef
+ 레퍼런스를 사용하기 위한 훅

### 5. 훅의 규칙
+ 최상위 레벨에서만 호출해야함
+ 함수형 컴포넌트에서만 훅을 호출해야함



## 6주차 23.04.06

### 1. 컴포넌트 추출
+ 여러개의 컴포넌트로 분리 가능
+ 부모 컴포넌트에서 추출
+ 1개의 컴포넌트에서 1의 기능 사용
+ 한눈에 알아보기 쉬움

### --6장--

### 1.state
+ State는 리액트 컴포넌트의 상태를 의미한다.
+ 컴포넌트의 데이터를 의미
+ 변경가는한 데이터를 의미
+ State가 변하면 다시 렌더링 되기 떄문에 렌더링 관련된 값만 state에 포함시켜야 한다.
### 2.특징
+ 리액트 만의 특별한 형태가 아닌 자바스크립트 객체이다. 
+   element - 재료
    component - 빵틀
    instance - 객체

### 3.생명주기
+ 생명주기는 컴포넌트의 생성 시점, 종료 시점을 나타낸 것
+ constructor가 실행 되면서 컴포넌트가 생성
+ 생성 직후 componentDidMount() 함수 호출
+ 컴포넌트가 소멸하기 전까지 여러 번 랜더링 함
+ 랜더링은 porps, setState(), forceUpdate()에 의해 상태가 변경되면 이루어짐
+ 렌더링이 끝나면 componentDinUpdate() 함수가 호출됨
+ 마지막으로 컴포넌트가 언마운트 되면 componentWillUnmount() 함수가 호출됨




## 5주차 23.03.30

### 1. element
    리액트 앱을 구성하는 요소
    
### 2. props
    1.속성의 준말
    2.컴포넌트의 속성
    3.어떤 속성,props에 따라 엘리먼트가 다르게 출력
    4.props는 컴포넌트에 전달 할 다양한 정보를 담고 있는 자바스크립트 객체

### 3.props의 특징
    1.읽기 전용 (변경x)
    2.속성이 다른 엘리먼트를 생성하려면 새로운 props를 컴포넌트에 전달해야함
    3. pure 함수 - 인수로 받은 정보가 함수 내부에서도 변하지 않는 함수
    4. impure 함수 - 인수로 받은 정보가 함수 내부에서 변하는 함수

### 4.컴포넌트의 종류
    1.이전에는 클래스형 컴포넌트를 주로 사용
    2.이후 Hook이라는 개념이 나오면서 함수형 컴포넌트를 주로 사용
    3.이전에는 클래스형 컴포넌트와 컴포넌트의 생명주기를 알야아야했음

### 5.컴포넌트 이름 찾기
    1.이름은 항상 대문자로 시작
    2.리액트는 소문자로 시작하는 컴포넌트를 DOM태그로 인식하기 때문


## 4주차 23.03.23

#### 1.JSX
    태그로 표현가능, 가독성때문에 사용
        ex) const element= <h1>HEllo, world</h1>; 

    따옴표 사용 
        ex) const element= 'name';
    
    빈 태그는 '/' 사용
        ex) <br/>
### 2.JSX의 역활
    1.내부적으로 XML/HTML 코드를 JAVA SCRIPT코드로 변환
    2.React가 creatElement함수를 사용해 자동으로 JAVA SCRIPT코드로 변환
    3.만일 JS로 작업할 경우 creatElement함수를 사용해야함
    4.가독성을 높여주는 역활을 수행

### 3.JSX의 장점
    1.간결한 코드
    2.가동성의 향상
    3.Injection Attack이라는 해킹방법을 방어함으로 보안에 강함
### 4.JSX의 사용법
    1.모든 자바스크립트 문법 지원
    2.자바 스크립트 문법 + XML + HTML
    3.만일 html이나 xml에 자바스크립트 코드를 사용하고싶으면 {}괄호를 사용
    
    태그의 속성값을 넣을 때
        1.큰따옴표 사이에 문자열 넣기
            ex) const element = <div tabIndex="0"></div>;
        2.중괄호 사이에 자바스크립트 코드 넣기
            ex) const element = <img src = {user.avatarurl}></img>;


## 3주차 23.03.16

### 1.웹사이트 chocolately 이용방법, node.js 설치
### 2.node버전 확인 명령어, npm 확인 명령어
    node --version
    npm --version
### 3.리액트 개념 정리
    - 복잡한 사이트를 쉽고 빠르게 만들고,관리하기 위해 만들어진 것
    - 다른 표현으로는 SPA를 쉽고 빠르게 만들 수 있도록 해주는 도구라고 생각하면 됨
### 4.장점
    - 빠른 업데이트와 렌더링 속도
        DOM 동기식 <-> Virtual DOM 비동기식
        DOM - XML,HTML 각 문서의 항목을 계층으로 표현해 생성,변형,삭제할 수 있도록 돕는 인터페이스
        Virtual DOM - DOM의 조작을 효율적으로 만들어 속도를 향상시킨 방법
### 5.컴포넌트 기반 구조
    - 리액트의 모든 페이지는 컴포넌트로 구성
    - 하나의 컴포넌트는 다른 여러 개의 컴포넌트의 조합으로 구성
### 6.재사용성
    - 반복적인 작업을 줄여서 생산성을 높임
    - 유지보수가 용이함
    - 재사용이 가능 하려면 해당 모듈의 의존성이 없어야 함
### 7.오픈소스, 활발할 지식공유, 모바일 앱 개발가능

### 8.단점
    - 방대한 학습량
    - 높은 상태 관리 복잡도


## 2주차 23.03.09 

### github연결 및 설정
    프로젝트 생성 명령어
        npx create-react-app 23-react1
    